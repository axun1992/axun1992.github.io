---
layout: post
title:  "UE多人网络学习"
tags: ue
---
在多人游戏会话中，游戏状态信息将通过网络连接在多台计算机之间传达。虚幻引擎（UE） 提供的网络框架非常强大，支持着世界上最流行的一些在线多人游戏，可帮助你简化此过程。
<!--more-->
# 虚幻引擎网络概述
服务器作为游戏主机保存一个真正的 权威 游戏状态。换句话说，服务器是多人游戏实际运行的地方。  
客户端各自控制它们在服务器上拥有的远程 Pawn 。客户端从其本地Pawn向其服务器Pawn发送 远程程序调用 以在游戏中执行操作。  
接着，服务器向每个客户端 复制 关于游戏状态的信息，例如 Actor 所在的位置，这些Actor应该具备怎样的行为，以及不同的变量应该有哪些值。然后每个客户端使用这些信息，近似模拟服务器上实际正在发生的情况。  
  
此过程在
- 基础Gameplay交互（碰撞、移动、损伤）
- 美化效果（视觉效果和声音）
- 玩家信息（HUD更新）

之间进行了划分。这三者各自与网络中的特定计算机或一组计算机关联。    
网络模式宏与构建目标的关系：  

|Target|UE_SERVER|WITH_SERVER_CODE|
|:-|:-|:-|
|Game|0|1|
|Server|1|1|
|Client|0|0|
  
  
复制是指权威服务器将状态数据发送到连接的客户端的过程。主要使用Actor和Actor派生的类通过UE中的网络连接复制其状态。  
AActor 是可以在关卡中放置或生成的对象的基类，也是UE的 UObject 继承层级中第一个支持用于网络的类。UObject 派生的类也可以复制，但必须作为复制的子对象附加到Actor才能恰当复制。  
默认情况下，大部分Actor不会复制，而是在本地执行其函数。你可以将C++中的 bReplicates 变量或蓝图中的 Replicates 设置设为 true ，为Actor派生的类启用复制。  
可用的不同复制功能：  

|功能|说明|
|:-:|:-|
|创建和销毁|服务器上生成可复制Actor的权威版本时，会在所有连接的客户端上生成远程代理。接着会将信息复制到这些远程代理。销毁权威Actor将自动销毁所有连接的客户端上的远程代理。|
|移动|Actor需启用bReplicateMovement|
|属性|Actor需重载GetLifetimeReplicatedProps函数，DOREPLIFETIME(ADerivedActor, Health);（看来是简单类型）|
|组件|组件需设为复制|
|子对象|从UObject派生的类，重载ReplicateSubobjects或使用注册子对象列表|
|远程程序调用|无论初始在哪台计算机上调用RPC，其实现将仅在目标计算机上运行|
  
创建、销毁、移动等常见用例会自动处理，但其他所有Gameplay功能在默认情况下不会复制，即使你为Actor启用复制也是如此。你必须手动指定。

网络编程法则：  
- 少用RPC，尽量用Replicated Using (RepNotify) property。
- 少用multicast函数。
- 仅服务器的逻辑如果可以保证在服务器上执行，则不需要放在Server RPC中。
- 当关联用户输入和Reliable RPCs时需警慎并限制频率，以避免可靠远程调用的栈溢出。
- 对经常调用的函数使用不可靠RPC。
- 尽量复用函数，同时被游戏逻辑和RepNotifies调用，以保证在客户端和服务器并行执行。
- 检查actor的网络角色，以过滤执行函数。
- 通过IsLocallyControlled来检查pawn是否是本地控制的。
- 使用网络休眠，这是最有效的优化之一。  
  
# 多人游戏中的关卡转移
有三个用来驱动转移的主要函数：  

|函数|说明|
|:-|:-|
|UEngine::Browse|非无缝加载|
|UWorld::ServerTravel|服务器使用|
|APlayerController::ClientTravel|客户端使用，也会在服务器转移时被自动调用|
  
# 详细的Actor复制流程
注：通过源码得知，**考虑复制列表**是全局只有一个的，**相关列表**是每个连接会产生一个，是从考虑复制列表中筛选出来的。  
NetDriver决定哪些Actor需要以什么顺序复制到哪些连接。  
Actor复制主要在`UNetDriver::ServerReplicateActors`函数，服务器首先收集与每个客户端相关的所有Actor，然后发送自上次更新之后的任何属性改动。  
然后`UActorChannel::ReplicateActor`函数负责具体处理，把Actor复制到特定通道。  
## 重要的属性
存在定义好的Actor更新流程，触发特定的框架回调，以及用来决定是否一个Actor在当前服务器Tick中是否更新的属性。以下是一些重要的：  

|Property|Description|
|:-|:-|
|`float AActor::NetUpdateFrequency`|Actor复制频率|
|`AActor::PreReplication(UNetDriver* NetDriver)`|复制之前的回调|
|`bool AActor::bOnlyRelevantToOwner`|是否只复制到所有者|
|`bool Actor::IsRelevancyOwnerFor(const AActor* ReplicatedActor,const AActor* ActorOwner,const AActor* ConnectionActor)`|当bOnlyRelevantToOwner为true时，用来确定相关性|
|`bool AActor::IsNetRelevantFor(const AActor* RealViewer,const AActor* ViewTarget,const FVector& SrcLocation)`|当bOnlyRelevantToOwner为false时，用来确定相关性|
|`TEnumAsByte<enum ENetDormancy> AActor::NetDormancy`|决定Actor休眠还是唤醒|
  
## Actor复制流程总览
1. 确定哪些Actor启用了复制并执行检查，以确定休眠、更新频率、拥有连接。
    1. 把通过检查的Actor添加到一个考虑复制列表。
2. 循环遍历每个连接，基于当前的Actor和连接进行检查。最后，每个连接得到一个考虑复制的Actor的列表。
    1. 每个连接的待复制Actor基于优先级排序。
3. 确定此Actor是否与此连接相关。
4. 复制此Actor到当前连接。

下面是每个步骤更详细的描述：  
### 添加Actor到考虑复制的列表
这一步会对所有Actor执行初始遍历，通过检查Actor是否调用了`AActor::SetReplicates(true)`来确定哪些Actor正在进行复制。  
对于每个启用了复制的Actor，NetDriver执行以下检查：  
1. 确定Actor是否一开始就休眠(`ENetDormancy::DORM_Initial`)。
    1. 如果是，跳过此Actor。
2. 通过`AActor::NetUpdateFrequency`值，决定Actor是否需要更新。
    1. 如果不需要，跳过此Actor。
3. 如果`AActor::bOnlyRelevantToOwner`为true，通过在Actor的拥有连接查看器上调用`AActor::IsRelevancyOwnerFor`，检查与Actor拥有连接的相关性。（注：从5.1源码上看无此操作，此操作应在**循环遍历排序后的Actor列表**步骤发生）
    1. 如果相关，添加到Actor拥有连接的**相关列表**。
    2. 这种情况下，Actor只会发送到单个连接。
  
对任何通过了初始遍历的Actor，将调用`AActor::PreReplication`。在此函数中你可以决定是否希望属性复制到特定的连接。使用`DOREPLIFETIME_ACTIVE_OVERRIDE`宏来控制Actor复制到哪些连接。  
如果Actor通过了上面所有检查，将被添加到**考虑复制列表**。

### 循环遍历每个连接
接着，系统循环遍历每个连接，为每个连接对**考虑复制列表**中每个Actor执行检查和操作：  
1. 通过`AActor::NetDormancy`调用确定当前Actor是否休眠。
    1. 如果Actor对当前连接休眠，跳过Actor。
2. 如果还没有通道：
    1. 确定客户端是否加载了当前Actor所在关卡。
        1. 如果关卡还没加载，跳过此Actor。
    2. 通过调用`AActor::IsNetRelevantFor`，确定当前Actor是否与当前连接相关。
        1. 如果不相关，跳过此Actor。
  
把上述Actor添加到连接的**相关列表**中。现在，每个连接的相关列表中都是未休眠Actor。对列表基于Actor优先级(`AActor::GetNetPriority`)降序排序。

#### 循环遍历排序后的Actor列表
循环遍历当前连接的**考虑复制列表**（注：从5.1源码分析此处应为**相关列表**）中的每个Actor:  
1. 如果连接还未加载Actor所在关卡，关闭通道。
2. 每1秒，通过调用`AActor::IsNetRelevantFor`，确定此Actor是否与此连接相关。
    1. 如果连续5秒不相关，关闭通道。
    2. 如果相关但没有打开的通道，开启一个通道。
    3. 如果任意时刻连接已饱和，对剩余的所有Actor：
        1. 如果相关少于1秒，下次tick强制一次更新。
        2. 如果相关多于1秒，调用`AActor::IsNetRelevantFor`来确定下次tick是否需要更新。
  
对于通过上述所有检查的Actor，将通过调用`UActorChannel::ReplicateActor`复制到连接。  

### 复制一个Actor到连接
`UActorChannel::ReplicateActor`是把Actor和它所有组件复制到连接的主要方法。  
它的流程大致是这样：  
1. 确定是否是通道打开之后的第一次更新。
    1. 如果是，序列化所需的特定的信息（初始位置，旋转等）。
2. 确定连接是否拥有此Actor。
    1. 如果不拥有，并且Actor的角色是`ENetRole::ROLE_AutonomousProxy`，降级到`ENetRole::ROLE_SimulatedProxy`。
3. 复制角色改变的属性。
4. 复制每个组件改变的属性。
5. 对于任何被删除的组件，发送一个特殊的删除命令。
  
列表中的Actor用完、或者通道饱和之后，重复处理下一个连接，直到所有连接被更新。

## 更多信息
- `/Engine/Source/Runtime/Engine/Classes/Engine/NetDriver.h`
    - Information about `UNetDriver::ServerReplicateActors`.
- `/Engine/Source/Runtime/Engine/Classes/GameFramework/Actor.h`
    - Information about `AActor` and its functions and properties.
- `/Engine/Source/Runtime/Engine/Classes/Engine/ActorChannel.h`
    - Information about `UActorChannel` and `UActorChannel::ReplicateActor`.
- `/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h`
    - Information about types such as `ENetRole` and `ENetDormancy`.